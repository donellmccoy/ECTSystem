// <auto-generated> This file has been auto generated by EF Core Power Tools. </auto-generated>
#nullable enable
using Microsoft.EntityFrameworkCore.Infrastructure;
using Microsoft.EntityFrameworkCore.Storage;
using System.Data.Common;
using System.Reflection;
using System.Threading;

namespace AF.ECT.Data.Extensions;

/// <summary>
/// Extension methods for DbContext to support raw SQL queries and stored procedures.
/// </summary>
public static class DbContextExtensions
{
    /// <summary>
    /// Executes a raw SQL query asynchronously and returns the results.
    /// </summary>
    /// <typeparam name="T">The type of objects to return from the query.</typeparam>
    /// <param name="db">The database context to execute the query against.</param>
    /// <param name="sql">The raw SQL query to execute.</param>
    /// <param name="parameters">The parameters to pass to the SQL query.</param>
    /// <param name="cancellationToken">A token to cancel the asynchronous operation.</param>
    /// <returns>A task representing the asynchronous operation, containing a list of query results or null.</returns>
    /// <exception cref="ArgumentNullException">Thrown when db or sql is null.</exception>
    [Obsolete("This method is obsolete and will be removed in the future.  Use SqlQueryToListAsync<T> instead when returning results.  Use dbContext.Database.ExecuteSqlRawAsync for calls with no results.")]
    public static async Task<List<T>?> SqlQueryAsync<T>(this DbContext db, string sql, object[]? parameters = null, CancellationToken? cancellationToken = default)
       where T : class
    {
        parameters ??= Array.Empty<object>();
        cancellationToken ??= CancellationToken.None;

        if (typeof(T).GetProperties().Any())
        {
            return await db.Database
                .SqlQueryRaw<T>(sql, parameters)
                .ToListAsync(cancellationToken.Value);
        }
        else
        {
            await db.Database.ExecuteSqlRawAsync(sql, parameters, cancellationToken);
            return default;
        }
    }

    /// <summary>
    /// Executes a raw SQL query asynchronously and returns the results as a list.
    /// </summary>
    /// <typeparam name="T">The type of objects to return from the query.</typeparam>
    /// <param name="db">The database context to execute the query against.</param>
    /// <param name="sql">The raw SQL query to execute.</param>
    /// <param name="parameters">The parameters to pass to the SQL query.</param>
    /// <param name="cancellationToken">A token to cancel the asynchronous operation.</param>
    /// <returns>A task representing the asynchronous operation, containing a list of query results.</returns>
    /// <exception cref="ArgumentNullException">Thrown when db or sql is null.</exception>
    public static async Task<List<T>> SqlQueryToListAsync<T>(this DbContext db, string sql, object[]? parameters = null, CancellationToken? cancellationToken = default)
        where T : class
    {
        // Convert parameters to be compatible with the current database provider
        var convertedParameters = ConvertParametersForProvider(db, parameters ?? Array.Empty<object>());

        try
        {
            return await db.Database
                .SqlQueryRaw<T>(sql, convertedParameters)
                .ToListAsync(cancellationToken ?? CancellationToken.None);
        }
        catch (InvalidOperationException ex) when (ex.Message.Contains("Sequence contains no elements"))
        {
            // Handle empty result sets from stored procedures gracefully
            // This can happen when EF Core tries to process result set metadata but finds no rows
            return new List<T>();
        }
    }

    /// <summary>
    /// Converts SQL parameters to be compatible with the current database provider.
    /// </summary>
    /// <param name="db">The database context.</param>
    /// <param name="parameters">The original parameters.</param>
    /// <returns>Parameters converted for the current database provider.</returns>
    private static object[] ConvertParametersForProvider(DbContext db, object[] parameters)
    {
        var providerName = db.Database.ProviderName;
        Console.WriteLine($"Database provider: {providerName}");

        // Always try to convert SqlParameter objects to avoid casting issues
        return ConvertToSqliteParameters(parameters);
    }

    /// <summary>
    /// Converts SqlParameter objects to SqliteParameter objects for SQLite compatibility.
    /// Uses reflection to avoid compile-time dependencies on SQLite assemblies.
    /// </summary>
    /// <param name="parameters">The original parameters.</param>
    /// <returns>Parameters converted to SqliteParameter using reflection.</returns>
    private static object[] ConvertToSqliteParameters(object[] parameters)
    {
        var converted = new object[parameters.Length];

        // Try to find types by searching through loaded assemblies
        Type? sqlParameterType = null;
        Type? sqliteParameterType = null;
        Type? sqliteTypeEnum = null;

        // First, try to load the SQL Client assembly explicitly
        try
        {
            var sqlClientAssembly = Assembly.Load("Microsoft.Data.SqlClient");
            sqlParameterType = sqlClientAssembly.GetType("Microsoft.Data.SqlClient.SqlParameter");
        }
        catch
        {
            // If loading fails, try to find it in loaded assemblies
            foreach (var assembly in AppDomain.CurrentDomain.GetAssemblies())
            {
                if (sqlParameterType == null)
                    sqlParameterType = assembly.GetType("Microsoft.Data.SqlClient.SqlParameter");
                if (sqlParameterType == null)
                    sqlParameterType = assembly.GetType("System.Data.SqlClient.SqlParameter");
            }
        }

        foreach (var assembly in AppDomain.CurrentDomain.GetAssemblies())
        {
            if (sqliteParameterType == null)
                sqliteParameterType = assembly.GetType("Microsoft.Data.Sqlite.SqliteParameter");
            if (sqliteTypeEnum == null)
                sqliteTypeEnum = assembly.GetType("Microsoft.Data.Sqlite.SqliteType");

            if (sqliteParameterType != null && sqliteTypeEnum != null)
                break;
        }

        // Debug logging
        Console.WriteLine($"SqlParameter type found: {sqlParameterType != null}");
        Console.WriteLine($"SqliteParameter type found: {sqliteParameterType != null}");
        Console.WriteLine($"SqliteType enum found: {sqliteTypeEnum != null}");

        if (sqlParameterType == null || sqliteParameterType == null || sqliteTypeEnum == null)
        {
            // If types aren't available, return parameters as-is
            Console.WriteLine("SQLite types not available, returning parameters as-is");
            return parameters;
        }

        for (int i = 0; i < parameters.Length; i++)
        {
            var param = parameters[i];
            Console.WriteLine($"Parameter {i}: {param?.GetType().FullName}");

            // Check if it's a SqlParameter (SQL Server specific)
            if (param != null && sqlParameterType.IsAssignableFrom(param.GetType()))
            {
                Console.WriteLine($"Converting SqlParameter: {param.GetType().FullName}");
                // Use reflection to create SqliteParameter
                var sqliteParam = Activator.CreateInstance(sqliteParameterType);

                // Copy properties using reflection
                CopyProperty(param, sqliteParam, "ParameterName");
                CopyProperty(param, sqliteParam, "Value");
                CopyProperty(param, sqliteParam, "Direction");
                CopyProperty(param, sqliteParam, "Size");

                // Convert SqlDbType to SqliteType if available
                var sqlDbTypeProperty = param.GetType().GetProperty("SqlDbType");
                if (sqlDbTypeProperty != null)
                {
                    var sqlDbTypeValue = sqlDbTypeProperty.GetValue(param);
                    if (sqlDbTypeValue != null)
                    {
                        var sqliteTypeValue = ConvertSqlDbTypeToSqliteType(sqlDbTypeValue, sqliteTypeEnum);
                        if (sqliteTypeValue != null)
                        {
                            var sqliteTypeProperty = sqliteParameterType.GetProperty("SqliteType");
                            sqliteTypeProperty?.SetValue(sqliteParam, sqliteTypeValue);
                        }
                    }
                }

                converted[i] = sqliteParam!;
                Console.WriteLine($"Converted to: {sqliteParam.GetType().FullName}");
            }
            else
            {
                // Keep as-is if not a SqlParameter
                converted[i] = param;
                Console.WriteLine("Parameter kept as-is");
            }
        }

        return converted;
    }

    /// <summary>
    /// Copies a property value from source to target using reflection.
    /// </summary>
    private static void CopyProperty(object source, object target, string propertyName)
    {
        var sourceProperty = source.GetType().GetProperty(propertyName);
        var targetProperty = target.GetType().GetProperty(propertyName);

        if (sourceProperty != null && targetProperty != null && targetProperty.CanWrite)
        {
            var value = sourceProperty.GetValue(source);
            targetProperty.SetValue(target, value);
        }
    }

    /// <summary>
    /// Converts SqlDbType enum value to SqliteType enum value using reflection.
    /// </summary>
    private static object? ConvertSqlDbTypeToSqliteType(object sqlDbTypeValue, Type sqliteTypeEnum)
    {
        // Get the string representation of the SqlDbType
        var sqlDbTypeString = sqlDbTypeValue.ToString();

        // Map common types
        string sqliteTypeString = sqlDbTypeString switch
        {
            "Int" or "BigInt" or "SmallInt" or "TinyInt" or "Bit" => "Integer",
            "Float" or "Real" or "Decimal" or "Money" or "SmallMoney" => "Real",
            "DateTime" or "DateTime2" or "Date" or "Time" or "Char" or "NChar" or "VarChar" or "NVarChar" or "Text" or "NText" => "Text",
            "Binary" or "VarBinary" or "Image" => "Blob",
            _ => "Text" // Default fallback
        };

        // Get the enum value
        try
        {
            return Enum.Parse(sqliteTypeEnum, sqliteTypeString);
        }
        catch
        {
            // If parsing fails, return null
            return null;
        }
    }

    /// <summary>
    /// Executes a raw SQL query asynchronously and returns two result sets.
    /// </summary>
    /// <typeparam name="T1">The type of objects to return from the first result set.</typeparam>
    /// <typeparam name="T2">The type of objects to return from the second result set.</typeparam>
    /// <param name="db">The database context to execute the query against.</param>
    /// <param name="sql">The raw SQL query to execute.</param>
    /// <param name="parameters">The parameters to pass to the SQL query.</param>
    /// <param name="cancellationToken">A token to cancel the asynchronous operation.</param>
    /// <returns>A tuple containing the first and second result sets.</returns>
    /// <exception cref="ArgumentNullException">Thrown when db or sql is null.</exception>
    public static async Task<(List<T1>, List<T2>)> SqlQueryToTwoResultSetsAsync<T1, T2>(
        this DbContext db, 
        string sql, 
        object[]? parameters = null, 
        CancellationToken? cancellationToken = default)
        where T1 : class
        where T2 : class
    {
        parameters ??= Array.Empty<object>();
        cancellationToken ??= CancellationToken.None;

        var connection = db.Database.GetDbConnection();
        var wasClosed = connection.State == System.Data.ConnectionState.Closed;
        
        try
        {
            if (wasClosed)
            {
                await connection.OpenAsync(cancellationToken.Value);
            }

            using var command = connection.CreateCommand();
            command.CommandText = sql;
            command.CommandType = System.Data.CommandType.Text;

            // Add parameters
            foreach (var param in parameters)
            {
                if (param is DbParameter dbParam)
                {
                    command.Parameters.Add(dbParam);
                }
            }

            using var reader = await command.ExecuteReaderAsync(cancellationToken.Value);
            
            // Read first result set
            var firstResults = new List<T1>();
            while (await reader.ReadAsync(cancellationToken.Value))
            {
                var instance = Activator.CreateInstance<T1>();
                MapReaderToObject(reader, instance);
                firstResults.Add(instance);
            }

            // Move to second result set
            var secondResults = new List<T2>();
            if (await reader.NextResultAsync(cancellationToken.Value))
            {
                while (await reader.ReadAsync(cancellationToken.Value))
                {
                    var instance = Activator.CreateInstance<T2>();
                    MapReaderToObject(reader, instance);
                    secondResults.Add(instance);
                }
            }

            return (firstResults, secondResults);
        }
        finally
        {
            if (wasClosed)
            {
                await connection.CloseAsync();
            }
        }
    }

    /// <summary>
    /// Maps a DbDataReader row to an object instance using reflection.
    /// </summary>
    /// <param name="reader">The data reader to map from.</param>
    /// <param name="instance">The object instance to map to.</param>
    private static void MapReaderToObject(DbDataReader reader, object instance)
    {
        var properties = instance.GetType().GetProperties(BindingFlags.Public | BindingFlags.Instance);
        
        for (int i = 0; i < reader.FieldCount; i++)
        {
            var columnName = reader.GetName(i);
            var property = properties.FirstOrDefault(p => 
                p.Name.Equals(columnName, StringComparison.OrdinalIgnoreCase) && p.CanWrite);

            if (property != null && !reader.IsDBNull(i))
            {
                var value = reader.GetValue(i);
                var targetType = Nullable.GetUnderlyingType(property.PropertyType) ?? property.PropertyType;
                
                if (value != null && value.GetType() != targetType)
                {
                    value = Convert.ChangeType(value, targetType);
                }
                
                property.SetValue(instance, value);
            }
        }
    }
}

/// <summary>
/// Represents an output parameter for stored procedure calls.
/// </summary>
/// <typeparam name="TValue">The type of the output parameter value.</typeparam>
public class OutputParameter<TValue>
{
    private bool _valueSet = false;

    private TValue? _value;

    /// <summary>
    /// Gets the value of the output parameter.
    /// </summary>
    /// <exception cref="InvalidOperationException">Thrown when attempting to get the value before it has been set.</exception>
    public TValue? Value
    {
        get
        {
            if (!_valueSet)
                throw new InvalidOperationException("Value not set.");

            return _value;
        }
    }

    /// <summary>
    /// Sets the value of the output parameter.
    /// </summary>
    /// <param name="value">The value to set for the output parameter.</param>
    internal void SetValue(object? value)
    {
        _valueSet = true;

        _value = null == value || Convert.IsDBNull(value) ? default(TValue) : (TValue)value;
    }
}
